#include <iostream>
#include <cstdlib>
#include <ctime>

#include "crypto.h"

unsigned long startTime;
unsigned long endTime;

int keygen(void){
	Digit prv[FP_DIGITS];
	Digit pub[2*FP_DIGITS];

	srand(clock());
	
	/* Now keys are generated using rand(). Instead of 0, you should
	 * substitute a reference to the function generating random bits.
	 *
	 * The function should have the following interface:
	 *
	 *   void rng(Digit *buf, int n)
	 *
	 * where buf is a buffer for random bits, and n is the number
	 * of generated random digits in the buffer.
	 */
	ecc_generate_key(pub, prv, 0);
	return 0;
}

// Static SERVER key pair generated by the keygen program.
Digit prvSrv[FP_DIGITS] = {
	0x2454fba4, 0x8da7f60f, 0x3373886b, 0xaf7eabb7, 0x72d6f1b9, 0x22674a67
};

Digit pubSrv[2*FP_DIGITS] = {
	0xd388264f, 0x3940a178, 0x10710de9, 0xb87bbf09, 0x1b7543dd, 0xd6b941e1, 0xc3a727d3, 0x37aa763e, 0x4a33547c, 0xfbbe8072, 0xe5390cd1, 0x9398e3d4
};

// Static MICROCONTROLLER (SENSOR) key pair generated by the keygen program.
Digit prvMu[FP_DIGITS] = {
	0x16b1c8fd, 0x0f7eeb08, 0x46a846f0, 0x32593b27, 0x059e4b50, 0x6bb0570f
};

Digit pubMu[2*FP_DIGITS] = {
	0xa2f1b4e6, 0xa3d59896, 0x555b859e, 0x0eb8e223, 0x77a021d3, 0x86883364, 0x2c151e28, 0xcfd3f377, 0xb7795ebf, 0xd59ad5c5, 0x9c0915a0, 0x1eaee60a
};

int iotpki(int B = 1) {
	std::cout << "START: iotpki()\n";
	// Initialization of variables and data structures ...

	ProtocolIoTPki ctxSrv;
	ProtocolIoTPki ctxMu;

	EcdsaSign q1SrvSign;
	Digit q1Srv[2*FP_DIGITS];
	EcdsaSign q1MuSign;
	Digit q1Mu[2*FP_DIGITS];

	Octet aesKeySrv[16];
	Octet aesKeyMu[16];

	int err = 0;

	clock_t startTime;
	clock_t endTime;

	// !!! START OF THE INTERACTIVE PROTOCOL SECTION !!!
	// [1 SRV] Protocol initialization, determination of q1Srv.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotpki_init(&ctxSrv, prvSrv, pubMu, 0)) != 0) {
			std::cout << "Err 10: " << err << "\n";
			return err;
		}

		if ((err = ecc_iotpki_q1(&ctxSrv, q1Srv, &q1SrvSign)) != 0) {
			std::cout << "Err 11: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[1 SRV] init(1M), q1(1Sig): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// Sending q1Srv and q1SrvSign to the microcontroller (sensor).
	// ...
	// Receiving q1Srv and q1SrvSign from the server.
	// [1 MU] Protocol initialization, determination of q1Mu.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotpki_init(&ctxMu, prvMu, pubSrv, 0)) != 0) {
			std::cout << "Err 12: " << err << "\n";
			return err;
		}

		if ((err = ecc_iotpki_q1(&ctxMu, q1Mu, &q1MuSign)) != 0) {
			std::cout << "Err 13: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[1 MU ] init(1M), q1(1Sig): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// Sending q1Mu and q1MuSign to the server.
	// ...
	// Receiving q1Mu and q1MuSign from the microcontroller (sensor).
	// [2 SRV] Determination of q2Srv.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotpki_q2(&ctxSrv, q1Mu, &q1MuSign)) != 0) {
			std::cout << "Err 14: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[2 SRV] q2(1M+1Ver): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// [2 MU] Determination of q3Mu.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotpki_q2(&ctxMu, q1Srv, &q1SrvSign)) != 0) {
			std::cout << "Err 15: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[2 MU ] q2(1M+1Ver): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// !!! END OF THE INTERACTIVE PROTOCOL SECTION.
	// [3 SRV] Determination of the hash and retrieval as the key for the AES-128 algorithm.
	startTime = clock();

	if ((err = ecc_iotpki_hash(&ctxSrv, aesKeySrv)) != 0) {
		std::cout << "Err 16: " << err << "\n";
		return err;
	}

	endTime = clock();
	std::cout << "[3 SRV] AES-128\n";

	// [3 MU] Determination of the hash and retrieval as the key for the AES-128 algorithm.
	startTime = clock();

	if ((err = ecc_iotpki_hash(&ctxMu, aesKeyMu)) != 0) {
		std::cout << "Err 17: " << err << "\n";
		return err;
	}

	endTime = clock();
	std::cout << "[3 MU ] AES-128\n";

	std::cout << "STOP: iotpki()\n";

	return 0;
}

int main(int argc, char *argv[]) {
	int B = 100;
	if (argc == 2) {
		B = atoi(argv[1]);
	}
	iotpki(B);
}
