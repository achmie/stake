#include <iostream>
#include <cstdlib>
#include <ctime>

#include "crypto.h"

unsigned long startTime;
unsigned long endTime;

int keygen(void){
	Digit prv[FP_DIGITS];
	Digit pub[2*FP_DIGITS];

	srand(10);

	/* Now keys are generated using rand(). Instead of 0, you should
	 * substitute a reference to the function generating random bits.
	 *
	 * The function should have the following interface:
	 *
	 *   void rng(Digit *buf, int n)
	 *
	 * where buf is a buffer for random bits, and n is the number
	 * of generated random digits in the buffer.
	 */
	ecc_generate_key(pub, prv, 0);
	return 0;
}

// Static SERVER key pair generated by the keygen program.
Digit prvSrv[FP_DIGITS] = {
	0x2454fba4, 0x8da7f60f, 0x3373886b, 0xaf7eabb7, 0x72d6f1b9, 0x22674a67
};

Digit pubSrv[2*FP_DIGITS] = {
	0xd388264f, 0x3940a178, 0x10710de9, 0xb87bbf09, 0x1b7543dd, 0xd6b941e1, 0xc3a727d3, 0x37aa763e, 0x4a33547c, 0xfbbe8072, 0xe5390cd1, 0x9398e3d4
};

// Static MICROCONTROLLER (SENSOR) key pair generated by the keygen program.
Digit prvMu[FP_DIGITS] = {
	0x16b1c8fd, 0x0f7eeb08, 0x46a846f0, 0x32593b27, 0x059e4b50, 0x6bb0570f
};

Digit pubMu[2*FP_DIGITS] = {
	0xa2f1b4e6, 0xa3d59896, 0x555b859e, 0x0eb8e223, 0x77a021d3, 0x86883364, 0x2c151e28, 0xcfd3f377, 0xb7795ebf, 0xd59ad5c5, 0x9c0915a0, 0x1eaee60a
};

int iotstake(int B = 1) {
	std::cout << "START: iotstake()\n";
	// Initialization of variables and data structures ...
	ProtocolIoTStake ctxSrv;
	ProtocolIoTStake ctxMu;

	Digit q1Srv[2*FP_DIGITS];
	Digit q2Srv[2*FP_DIGITS];
	Digit q1Mu[2*FP_DIGITS];
	Digit q2Mu[2*FP_DIGITS];

	Octet aesKeySrv[16];
	Octet aesKeyMu[16];

	int err = 0;

	clock_t startTime;
	clock_t endTime;

	// !!! START OF THE INTERACTIVE PROTOCOL SECTION !!!
	// [1 SRV] Protocol initialization, determination of q1Srv.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotstake_init(&ctxSrv, prvSrv, pubMu, 0)) != 0) {
			std::cout << "Err 0: " << err << "\n";
			return err;
		}

		if ((err = ecc_iotstake_q1(&ctxSrv, q1Srv)) != 0) {
			std::cout << "Err 1: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[1 SRV] init(1M), q1(1M): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// Sending q1Srv to the microcontroller (sensor).
	// ...
	// Receiving q1Srv from the server.
	// [1 MU] Protocol initialization, determination of q1Mu and q2Srv.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotstake_init(&ctxMu, prvMu, pubSrv, 0)) != 0) {
			std::cout << "Err 2: " << err << "\n";
			return err;
		}

		if ((err = ecc_iotstake_q1(&ctxMu, q1Mu)) != 0) {
			std::cout << "Err 3: " << err << "\n";
			return err;
		}

		if ((err = ecc_iotstake_q2(&ctxMu, q1Srv, q2Srv)) != 0) {
			std::cout << "Err 4: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[1 MU ] init(1M), q1(1M), q2(1M): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// Sending q1Mu and q2Srv to the server.
	// ...
	// Receiving q1Mu, q2Srv from the microcontroller (sensor).
	// [2 SRV] Determination of q2Mu and q3Srv.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotstake_q2(&ctxSrv, q1Mu, q2Mu)) != 0) {
			std::cout << "Err 5: " << err << "\n";
			return err;
		}

		if ((err = ecc_iotstake_q3(&ctxSrv, q2Srv)) != 0) {
			std::cout << "Err 6: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[2 SRV] q2(1M), q3(1M): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// Sending q2Mu to the microcontroller (sensor).
	// ...
	// Receiving q2Mu from the server.
	// [2 MU] Determination of q3Mu.
	startTime = clock();

	for (int i = 0; i < B; i++) {
		if ((err = ecc_iotstake_q3(&ctxMu, q2Mu)) != 0) {
			std::cout << "Err 7: " << err << "\n";
			return err;
		}
	}

	endTime = clock();
	std::cout << "[2 MU ] q3(1M): ";
	std::cout << ((double)(endTime - startTime)/(B*CLOCKS_PER_SEC)) << "ms\n";

	// !!! END OF THE INTERACTIVE PROTOCOL SECTION.
	// [3 SRV] Determination of the hash and retrieval as the key for the AES-128 algorithm.
	startTime = clock();

	if ((err = ecc_iotstake_hash(&ctxSrv, aesKeySrv)) != 0) {
		std::cout << "Err 8: " << err << "\n";
		return err;
	}

	endTime = clock();
	std::cout << "[3 SRV] AES-128\n";

	// [3 MU] Determination of the hash and retrieval as the key for the AES-128 algorithm.
	startTime = clock();

	if ((err = ecc_iotstake_hash(&ctxMu, aesKeyMu)) != 0) {
		std::cout << "Err 9: " << err << "\n";
		return err;
	}

	endTime = clock();
	std::cout << "[3 MU ] AES-128\n";

	std::cout << "STOP: iotstake()\n";

	return 0;
}

int main(int argc, char *argv[]) {
	int B = 100;
	if (argc == 2) {
		B = atoi(argv[1]);
	}
	iotstake(B);
}
